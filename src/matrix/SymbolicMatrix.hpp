// #pragma once
// #include <Eigen/Sparse>
// #include <iostream>
// #include <array>
// #include <assert.h>
// #include <unordered_map>
// #include "Symbolic.hpp"
// #include "OperationsMatrix.hpp"
// #include <vector>

// namespace Sym {


// class SymbolicMatrix {
// public:
//     int matrixID; // the id of the matrix, data vector will respect this id
//     int referenceCount; // how many times this matrix has been referenced in computation
//     SymbolicMatrix(const Eigen::SparseMatrix<double>& m, int matrixID); // initialization of the symbolic matrix
//     SymbolicMatrix(const OpTypeMatrix opm, const SymbolicMatrix& m0, const SymbolicMatrix& m1); // this defines a matrix that is generated by a binary operation
//     SymbolicMatrix(const OpTypeMatrix opm, const SymbolicMatrix& m0); // this defines a matrix that is generated by a unary operation
//     // SymbolicMatrix(const OpTypeMatrix opm, const std::vector<SymbolicMatrix>& ms); // this defines a tree that is flattened, so like A * B * C
//     OpTypeMatrix op; // what operation is done on this matrix
//     const Symbolic& getSymbolicRepresentation() const;
//     SymbolicMatrix transpose(); // return a symbokic matrix that is transposed, the matrix itself won't be transposed now

//     const SymbolicMatrix* data() const { return this; } // this function exists for logistics
//     int size() const { return 0; } // this function exists for logistics


//     bool isInput() const { return this->isInputMatrix; } // check if itself is input matrix


// private:
//     int maximumElementsPerRow; // records this so we can generate trees in advance
//     int maximumElementsPerColumn; // records this so we can generate trees in advance
//     bool isInputMatrix; // if this matrix is directly initialized as an eigen matrix
//     int numRows;
//     int numCols;
//     int nnz; // number of non zeros
//     Symbolic symbolicRepresentation; // imagine instead of viewing it as a matrix, we treat it as a single data
//     int numChilds = 0;
//     SymbolicMatrix* childs;
// };
// }