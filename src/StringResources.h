#pragma once

#include <string>

template<class T>
std::string realTString() {return "";}

template<>
std::string realTString<double>() {return "double";}

template<>
std::string realTString<float>() {return "float";}


template<class T>
std::string cudaHeader() {
    return
        "#include <fstream>\n"
        "#include <vector>\n"
        "#include <cmath>\n"
        "#include <algorithm>\n"
        "#include <iostream>\n"
        "#include <cuda.h>\n"
        "#include <helper_cuda.h>\n"
        "#include <cuda_runtime_api.h>\n"
        "\n"
        "#define SYNC CHECK(cudaStreamSynchronize(stream))\n"
        "#define CHECK(ans) { gpuAssert((ans), __FILE__, __LINE__); }\n"
        "inline void gpuAssert(cudaError_t code, const char* file, int line, bool abort = true) {\n"
        "   if (code != cudaSuccess) {\n"
        "        fprintf(stderr, \"GPUassert: %s. code %d %s %d\\n\", cudaGetErrorString(code), code, file, line);\n"
        "        if (abort) exit(code);\n"
        "    }\n"
        " }\n"

        "\n"
        "#define KERNEL __global__\n"
        "typedef unsigned int INDEX;\n"
        "typedef " + realTString<T>() + " RealT;\n"
        "\n"
        "#ifdef _WIN32\n"
        "#define restrict __restrict\n"
        "#define EXPORT __declspec(dllexport)\n"
        "#else\n"
        "#define restrict __restrict__\n"
        "#define EXPORT\n"
        "#endif\n"
        "\n"
        "#define K(num) k##num<<<1 + (numInstances[num] - 1) / numThreads, numThreads,  0, stream>>>(x_d, c_d + constantsOffset[ num ], x_d + outputOffset[ num ], p_d + indexOffset[ num ] )"
        "\n"
        "extern \"C\" {\n"
        "EXPORT void init(const unsigned int* indexData, const unsigned int* outIndexData, const RealT* constData);\n"
        "EXPORT void run();\n"
        "EXPORT void finish();\n"
        "EXPORT void setArg(const RealT* d, int i);\n"
        "EXPORT void getResult(RealT* d, int i);\n"
        "}\n"
        "\n"
        "using namespace std;\n"
        "\n"
        "cudaStream_t stream;\n"
        "RealT* x_d = nullptr;\n"
        "RealT* gatherBuffer_d = nullptr;\n"
        "RealT* c_d = nullptr;\n"
        "unsigned int* p_d = nullptr;\n"
        "unsigned int* outIds_d = nullptr;\n";
}

const std::string cudaFooter =
"__global__ void gatherResult(RealT* x, RealT* d, const unsigned int* outIdsK, const int n) {\n"
"    const unsigned int i = threadIdx.x + blockDim.x * blockIdx.x;\n"
"    if(i < n) d[i] = x[outIdsK[i]];\n"
"}\n"
"\n"
"EXPORT void init(const unsigned int* indexData, const unsigned int* outIndexData, const RealT* constData) {\n"
"\n"
"    CHECK(cudaStreamCreate(&stream));\n"
"    CHECK(cudaMalloc(&x_d, sizeof(RealT) * numTotalMemory));\n"
"\n"
"    const size_t maxOutLen = numOuts ? *max_element(outputIndexLength, outputIndexLength + numOuts) : 0;\n"
"    CHECK(cudaMalloc(&gatherBuffer_d, sizeof(RealT) * maxOutLen));\n"
"\n"
"    CHECK(cudaMalloc(&p_d, sizeof(INDEX) * numIndizes));\n"
"\n"
"    if(indexData) {\n"
"        CHECK(cudaMemcpy(p_d, indexData, sizeof(INDEX) * numIndizes, cudaMemcpyHostToDevice));\n"
"    } else {\n"
"        unsigned int* p  = new unsigned int[numIndizes];\n"
"        std::ifstream file(\"indexData\", ios::in | ios::binary);\n"
"        file.read((char*)p, sizeof(unsigned int) * numIndizes);\n"
"        file.close();\n"
"        CHECK(cudaMemcpy(p_d, p, sizeof(INDEX) * numIndizes, cudaMemcpyHostToDevice));\n"
"        delete[] p;\n"
"    }\n"

"\n"
"    CHECK(cudaMalloc(&c_d, sizeof(RealT) * numConst));\n"
"\n"
"    if(constData) {\n"
"        CHECK(cudaMemcpy(c_d, constData, sizeof(RealT) * numConst, cudaMemcpyHostToDevice));\n"
"    } else {\n"
"        RealT* c = new RealT[numConst];\n"
"        std::ifstream file(\"constData\", ios::in | ios::binary);\n"
"        file.read((char*)c, sizeof(RealT) * numConst);\n"
"        file.close();\n"
"        CHECK(cudaMemcpy(c_d, c, sizeof(RealT) * numConst, cudaMemcpyHostToDevice));\n"
"        delete[] c;\n"
"    }\n"
"\n"
"    CHECK(cudaMalloc(&outIds_d, sizeof(INDEX) * numOutputValues));\n"
"\n"
"    if(outIndexData) {\n"
"        CHECK(cudaMemcpy(outIds_d, outIndexData, sizeof(INDEX) * numOutputValues, cudaMemcpyHostToDevice));\n"
"    } else {\n"
"        INDEX* out = new INDEX[numOutputValues];\n"
"        std::ifstream file(\"outIndexData\", ios::in | ios::binary);\n"
"        file.read((char*)out, sizeof(unsigned int) * numOutputValues);\n"
"        file.close();\n"
"        CHECK(cudaMemcpy(outIds_d, out, sizeof(INDEX) * numOutputValues, cudaMemcpyHostToDevice));\n"
"        delete[] out;\n"
"    }\n"
"\n"
"}\n"
"\n"
"EXPORT void setArg(const RealT* d, int i) {\n"
"    CHECK(cudaMemcpy(x_d + argStart[i], d, sizeof(RealT) * argLength[i], cudaMemcpyHostToDevice));\n"
"}\n"
"\n"
"EXPORT void getResult(RealT* d, int k) {\n"
"    const size_t n = outputIndexLength[k];\n"
"    gatherResult<<<1 + (n - 1) / numThreads, numThreads, 0, stream>>>(x_d, gatherBuffer_d, outIds_d + outputIndexStart[k], n);\n"
"    CHECK(cudaMemcpy(d, gatherBuffer_d, sizeof(RealT) * n, cudaMemcpyDeviceToHost));\n"
"    CHECK(cudaStreamSynchronize(stream));\n"
"}\n"
"\n"
"EXPORT void finish() {\n"

"}\n"
"\n"

"#ifdef APP\n"
"#include <iostream>\n"
"#include \"Timer.hpp\"\n"
"\n"
"int main() {\n"
"\n"
"    init(0,0,0);\n"
"    vector<RealT> r(argLength[0]);\n"
"    for (int i = 0; i < argLength[0]; ++i) r[i] = (12345 * i + 65346) % 1337;\n"
"    setArg(r.data(), 0);\n"
"\n"
"    for (int i = 0; i < 100; ++i) run();\n"
"\n"
"    Timer t;\n"
"    for (int i = 0; i < 100; ++i) run();\n"
"    t.printTime();\n"
"\n"
"    return 0;\n"
"}\n"
"\n"
"#endif\n";


template<class T>
std::string cpuHeader() {
    return
    "#include <fstream>\n"
    "#include <vector>\n"
    "#include <cmath>\n"
    "#include <algorithm>\n"
    "#include <iostream>\n"
    "#include <cstdlib>\n"
    "\n"
    "#define ICC 1\n"
    "#define CLANG 2\n"
    "#define GCC 3\n"
    "#define CL 4\n"
    "\n"
    "#define SYNC\n"
    "#define KERNEL\n"
    "typedef unsigned int INDEX;\n"
    "typedef " + realTString<T>() + " RealT;\n"
    "\n"
    "#if defined(__INTEL_COMPILER)\n"
    "#define COMPILER ICC\n"
    "#elif defined(__CLANG__)\n"
    "#define COMPILER CLANG\n"
    "#elif defined(_WIN32)\n"
    "#define COMPILER CL\n"
    "#else\n"
    "#define COMPILER GCC\n"
    "#endif\n"
    "\n"
    "\n"
    "#define FORISERIAL(end) for(INDEX i = 0; i < end; ++i) {\n"
    "#define ENDFORISERIAL }\n"
    "\n"
    "#ifndef NUMTHREADS\n"
    "    #define NUMTHREADS 1\n"
    "#endif\n"
    "\n"
    "#if NUMTHREADS == 1\n"
    "    #define FORI(end) FORISERIAL(end)\n"
    "    #define ENDFORI ENDFORISERIAL\n"
    "#else\n"
    "    #include <omp.h>\n"
    "\n"
    "    #if COMPILER == CL\n"
    "    #define FORI(end) __pragma(omp parallel for)  for (int i = 0; i < end; ++i) {\n"
    "    #else\n"
    "    #define FORI(end) _Pragma(\"omp parallel for\")  for (int i = 0; i < end; ++i) {\n"
    "    #endif\n"
    "    #define ENDFORI };\n"
    "#endif\n"
    "\n"
    "#if COMPILER == ICC\n"
    "    #define restrict __restrict\n"
    "    #define FORCEVECTORIZE(w) _Pragma(\"ivdep\")\n"
    "\n"
    "    #if NUMTHREADS != 1\n"
    "        #define FORI(end) tbb::parallel_for(INDEX(0), INDEX(end), [&](INDEX i) {\n"
    "        #define ENDFORI });\n"
    "        #include <tbb/parallel_for.h>\n"
    "    #endif\n"
    "#endif\n"
    "\n"
    "#if COMPILER == CLANG\n"
    "    #define restrict __restrict__\n"
    "    \n"
    "    #define ARG2 \"clang loop vectorize(assume_safety) vectorize_width(2)\"\n"
    "    #define ARG4 \"clang loop vectorize(assume_safety) vectorize_width(4)\"\n"
    "    #define ARG8 \"clang loop vectorize(assume_safety) vectorize_width(8)\"\n"
    "    #define ARG16 \"clang loop vectorize(assume_safety) vectorize_width(16)\"\n"
    "    #define FORCEVECTORIZE(w) _Pragma( ARG##w )\n"
    "\n"

    "#endif\n"
    "\n"
    "#if COMPILER==GCC\n"
    "    #define restrict __restrict__\n"
    "    #define FORCEVECTORIZE(w) _Pragma(\"ivdep\")\n"
    "#endif\n"
    "\n"
    "#if COMPILER==CL\n"
    "#define restrict __restrict\n"
    "#define FORCEVECTORIZE(w) __pragma(loop(ivdep))\n"
    "#define EXPORT __declspec(dllexport)\n"
    "#else\n"
    "#define EXPORT\n"
    "#endif\n"
    "\n"
    "#define K(num) k##num(x.data(), c + constantsOffset[ num ], x.data() + outputOffset[ num ], p + indexOffset[ num ] )\n"
    "\n"
    "extern \"C\" {\n"
    "EXPORT void init(const unsigned int* indexData, const unsigned int* outIndexData, const RealT* constData);\n"
    "EXPORT void run();\n"
    "EXPORT void finish();\n"
    "EXPORT void setArg(const RealT* d, int i);\n"
    "EXPORT void getResult(RealT* d, int i);\n"
    "}\n"
    "\n"
    "using namespace std;\n"
    "\n"
    "vector<RealT> x;\n"
    "const RealT* cBuff = nullptr;\n"
    "const RealT* c;\n"
    "const unsigned int* pBuff = nullptr;\n"
    "const unsigned int* p;\n"
    "const unsigned int* oBuff = nullptr;\n"
    "const unsigned int* outIds;\n"
    "\n";
}


const std::string cpuFooter =
"\n"
"EXPORT void init(const unsigned int* indexData = nullptr, const unsigned int* outIndexData = nullptr, const RealT* constData = nullptr) {\n"
"\n"
"    #if NUMTHREADS != 1\n"
"        omp_set_num_threads(NUMTHREADS);\n"
"    #endif\n"
"\n"
"    x.resize(numTotalMemory);\n"
"\n"

"    if(indexData) {\n"
"        p = indexData;\n"
"    } else {\n"
"        pBuff = new unsigned int[numIndizes];\n"
"        p = pBuff;\n"
"        std::ifstream file(\"indexData\", ios::in | ios::binary);\n"
"        file.read((char*)p, sizeof(unsigned int) * numIndizes);\n"
"        file.close();\n"
"    }\n"
"\n"
"    if(constData) {\n"
"        c = constData;\n"
"    } else {\n"
"        cBuff = new RealT[numConst];\n"
"        c = cBuff;\n"
"        std::ifstream file(\"constData\", ios::in | ios::binary);\n"
"        file.read((char*)c, sizeof(RealT) * numConst);\n"
"        file.close();\n"
"    }\n"
"\n"
"    if(outIndexData) {\n"
"        outIds = outIndexData;\n"
"    } else {\n"
"        oBuff = new unsigned int[numOutputValues];\n"
"        outIds = oBuff;\n"
"        std::ifstream file(\"outIndexData\", ios::in | ios::binary);\n"
"        file.read((char*)outIds, sizeof(unsigned int) * numOutputValues);\n"
"        file.close();\n"
"    }\n"
"\n"
"}\n"
"\n"
"EXPORT void setArg(const RealT* d, int i) {\n"
"    copy_n(d, argLength[i], x.data() + argStart[i]);\n"
"}\n"
"\n"
"EXPORT void getResult(RealT* d, int k) {\n"
"    const unsigned int* outIdsK = outIds + outputIndexStart[k];\n"
"    for(int i = 0; i < outputIndexLength[k]; ++i)\n"
"        d[i] = x[outIdsK[i]];\n"
"}\n"
"\n"
"EXPORT void finish() {\n"
"    if(pBuff) delete[] pBuff;\n"
"    if(cBuff) delete[] cBuff;\n"
"    if(oBuff) delete[] oBuff;\n"
"}\n";
